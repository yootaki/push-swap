# push-swap

## 概要
このプロジェクトでは、スタック上のデータを、限られた命令セットを使って、できるだけ少ないアクション数でソートします。
成功させるためには、様々なタイプのアルゴリズムを操作し、最適化されたデータソートのための最も適切なソリューションを選択する必要があります。

## 第2章
### はじめに
Push_swapプロジェクトは、非常にシンプルで効果的なアルゴリズムのプロジェクトです。データをソートする必要があります。
データをソートする必要があります。自由に使えるのは、int値のセット、2つのスタック、そして両方のスタックを操作する命令セットです。
あなたの目標は？受け取った整数の引数をソートするPush_swap命令言語を使用して、最小のプログラムを計算し、標準出力に表示するPush_swapと呼ばれるC言語のプログラムを記述します。
簡単ですか？
どうかな？

## 第3章
### 目標
ソートアルゴリズムを書くことは、コーダーの人生において非常に重要なステップです。
複雑さの概念に初めて触れることになるからだ。
ソートアルゴリズムとその複雑さは、就職面接で語られる典型的な質問の一部だ。
いつかは直面しなければならないからこそ、これらの概念に目を向ける良い機会なのかもしれません。
このプロジェクトの学習目標は、厳密さ、C言語の使用、基本的なアルゴリズムの使用です。
特に、これらの基本的なアルゴリズムの複雑さに注目しています。
値をソートするのは簡単です。
特に、ある整数構成から別の整数構成になると、最も効率的なソートアルゴリズムが異なる可能性があるため、可能な限り早い方法でソートすることは、それほど単純ではありません。

## 第4章
### 一般的な説明
- このプロジェクトは、実際の人間によってのみ修正されます。そのため、ファイルの構成や名前は自由ですが、以下のような要件を守る必要があります。
- 実行ファイルの名前は必ず push_swap としてください。
- Makefileを提出する必要があります。そのMakefileはプロジェクトをコンパイルする必要があり、通常のルールを含んでいなければなりません。Makefileは必要に応じてプログラムを再コンパイルするだけです。
- もしあなたが賢いのであれば、このプロジェクトに自分のライブラリを使い、リポジトリのルートに自分のMakefileを含むlibftフォルダも提出してください。あなたのMakefileはライブラリをコンパイルした後、あなたのプロジェクトをコンパイルしなければなりません。
- グローバル変数は使用できません。
- あなたのプロジェクトは、Normに従ってCで書かれていなければなりません。
- エラー処理は慎重に行わなければなりません。予期せぬ方法でプログラムを終了させることはできません（セグメンテーションフォールト、バスエラー、ダブルフリーなど）。
- プログラムにメモリリークがあってはなりません。
- 必須パートでは、以下の機能の使用が許可されています。
◦ write
◦ read
◦ malloc
◦ free
◦ exit

## 第5章
### 必須項目
V.1 ゲームのルール
- このゲームは、aとbという2つのスタックで構成されています。
- まず始めに
aには、正負の数の乱数が重複せずに入ります。
重複していません。
bは空である。
- ゲームの目的は、スタック a に入っている数字を昇順に並べ替えることです。

- そのためには、以下のような操作が必要です。
sa : swap a - スタックaの先頭の2つの要素を入れ替えます。要素が1つしかない場合やない場合は何もしません。)
sb : swap b - スタックbの一番上にある最初の2つの要素を入れ替える。)
ss : sa と sb を同時に実行します。
pa : push a - bの先頭の要素を取り、aの先頭に置く。bが空の場合は何もしない。
pb : push b - a の先頭の要素を取り、b の先頭に置きます。
ra : rotate a - スタックaの全ての要素を1ずつシフトアップします。
rb : rotate b - スタックbの全ての要素を1ずつ上に移動させる。
rr : ra と rb を同時に実行します。
rra : reverse rotate a - スタック a の全ての要素を 1 ずつ下にシフトします。
rrb : reverse rotate b - スタック b の全ての要素を 1 ずつ下にシフトします。
rrr : rra と rrb を同時に実行します。

V.2 例
これらの命令のいくつかの効果を説明するために、整数のランダムなリストをソートしてみましょう。
この例では、両方のスタックが右から増えていくと考えます。
この例では、12命令でaから整数をソートしています。あなたはもっとうまくできますか？

V.3 「push_swap」プログラム
- push_swapというプログラムを書いてください。このプログラムは、整数のリストとしてフォーマットされたスタックを引数として受け取ります。最初の引数はスタックの一番上でなければなりません（順序に注意してください）。
- プログラムは、スタックaをソートするために可能な限り小さな命令のリストを表示しなければなりません。
- 命令は「\n」で区切られ、他には何もない。
- 目標は、可能な限り最小の操作数でスタックをソートすることです。
ディフェンスでは、プログラムが見つけた命令の数と、許容される最大の操作数を比較します。プログラムが大きすぎるリストを表示したり、リストが適切にソートされていない場合は、ポイントを獲得できません。
- エラーが発生した場合には、標準エラーにErrorの後に'\n'を表示しなければなりません。
- エラーには、例えば
- - いくつかの引数が整数ではない(数字以外を除外)
- - いくつかの引数が整数より大きい(int範囲外)
- - 重複がある

防衛省では、あなたのプログラムを適切にチェックするためのバイナリーを提供します。これは次のように動作します。

checker_OSプログラムがKOを表示した場合、それはあなたのpush_swapがリストをソートしない命令のリストを出したことを意味します。
checker_OSのプログラムは、イントラネットのプロジェクトのリソースにあります。
このドキュメントのボーナスセクションには、その仕組みについての説明があります。

## 第六章
### ボーナスパート
ボーナスパートを見るのは、必須パートが優秀な場合に限られます。
つまり、必須パートを最初から最後まで完成させる必要があり、エラー管理が完璧である必要があります（ひねくれた使い方をした場合でも）。
もしそうでなければ、あなたのボーナスは完全に無視されてしまいます。
自分でチェッカーをコード化したら、どんなに面白いだろうか？とっても面白いですよ!

VI.1 "checker "プログラム
- checkerという名前のプログラムを書きましょう。このプログラムは、整数のリストとしてフォーマットされたスタックを引数として受け取ります。最初の引数はスタックの一番上でなければなりません (順序に注意してください)。引数が与えられなかった場合、checker は停止し、何も表示しません。
- checker は、標準入力上の命令を読んで待ちます。各命令の後には '\n' が続きます。すべての命令が読み込まれると、checker は引数として受け取ったスタック上の命令を実行します。
- これらの命令を実行した後、スタック a が実際にソートされ、b が空になった場合、チェッカーは標準出力に「OK」と表示し、その後に「˶ˆ꒳ˆ˵」を表示しなければなりません。それ以外の場合は、チェッカーは「KO」の後に「\n」を標準出力に表示しなければなりません。
- エラーが発生した場合は、標準エラー出力に「Error」を表示し、「˶ˆ꒳ˆ˵」を表示しなければなりません。エラーとは、例えば、引数が整数でない、引数が整数より大きい、重複している、命令が存在しない、フォーマットが間違っている、などです。チェッカープログラムのおかげで、push_swapプログラムで生成された命令のリストが、実際にスタックを正しくソートしているかどうかをチェックすることができます。

## 第7章
### 提出と相互修正
通常通りGiTリポジトリに作品を投稿してください。あなたのリポジトリにある作品のみが採点されます。
皆さん、頑張ってください。
